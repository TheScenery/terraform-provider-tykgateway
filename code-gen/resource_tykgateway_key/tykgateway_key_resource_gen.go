// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_tykgateway_key

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func TykgatewayKeyResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"access_rights": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"allow_urls": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"methods": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "HTTP methods allowed for the URL.",
										MarkdownDescription: "HTTP methods allowed for the URL.",
									},
									"url": schema.StringAttribute{
										Optional:            true,
										Description:         "Allowed URL.",
										MarkdownDescription: "Allowed URL.",
									},
								},
								CustomType: AllowUrlsType{
									ObjectType: types.ObjectType{
										AttrTypes: AllowUrlsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "List of allowed URLs for the key.",
							MarkdownDescription: "List of allowed URLs for the key.",
						},
						"api_id": schema.StringAttribute{
							Optional:            true,
							Description:         "API ID.",
							MarkdownDescription: "API ID.",
						},
						"api_name": schema.StringAttribute{
							Optional:            true,
							Description:         "API name.",
							MarkdownDescription: "API name.",
						},
						"limit": schema.ObjectAttribute{
							AttributeTypes: map[string]attr.Type{
								"rate":                 types.Float64Type,
								"per":                  types.Float64Type,
								"throttle_interval":    types.Float64Type,
								"throttle_retry_limit": types.Int64Type,
								"max_query_depth":      types.Int64Type,
								"quota_max":            types.Int64Type,
								"quota_renews":         types.Int64Type,
								"quota_remaining":      types.Int64Type,
								"quota_renewal_rate":   types.Int64Type,
							},
							Optional:            true,
							Description:         "Rate limiting configuration for the key.",
							MarkdownDescription: "Rate limiting configuration for the key.",
						},
						"versions": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "List of API versions.",
							MarkdownDescription: "List of API versions.",
						},
					},
					CustomType: AccessRightsType{
						ObjectType: types.ObjectType{
							AttrTypes: AccessRightsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Access rights for the key, mapping API IDs to access definitions.",
				MarkdownDescription: "Access rights for the key, mapping API IDs to access definitions.",
			},
			"alias": schema.StringAttribute{
				Optional:            true,
				Description:         "Alias for the key.",
				MarkdownDescription: "Alias for the key.",
			},
			"allowance": schema.Float64Attribute{
				Required:            true,
				Description:         "The number of requests allowed for the API key.",
				MarkdownDescription: "The number of requests allowed for the API key.",
			},
			"apply_policies": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "List of policy IDs to apply to the key.",
				MarkdownDescription: "List of policy IDs to apply to the key.",
			},
			"basic_auth_data": schema.ObjectAttribute{
				AttributeTypes: map[string]attr.Type{
					"password":  types.StringType,
					"hash_type": types.StringType,
				},
				Optional:            true,
				Description:         "Basic authentication data.",
				MarkdownDescription: "Basic authentication data.",
			},
			"certificate": schema.StringAttribute{
				Optional:            true,
				Description:         "Certificate.",
				MarkdownDescription: "Certificate.",
			},
			"data_expires": schema.Int64Attribute{
				Optional:            true,
				Description:         "Data expiration time.",
				MarkdownDescription: "Data expiration time.",
			},
			"date_created": schema.StringAttribute{
				Optional:            true,
				Description:         "The date and time when the API key was created, in Unix timestamp format.",
				MarkdownDescription: "The date and time when the API key was created, in Unix timestamp format.",
			},
			"enable_detailed_recording": schema.BoolAttribute{
				Optional:            true,
				Description:         "Enable detailed recording.",
				MarkdownDescription: "Enable detailed recording.",
			},
			"enable_http_signature_validation": schema.BoolAttribute{
				Optional:            true,
				Description:         "Enable HTTP signature validation.",
				MarkdownDescription: "Enable HTTP signature validation.",
			},
			"expires": schema.Int64Attribute{
				Optional:            true,
				Description:         "The expiration time of the API key, in Unix timestamp format.",
				MarkdownDescription: "The expiration time of the API key, in Unix timestamp format.",
			},
			"hmac_enabled": schema.BoolAttribute{
				Optional:            true,
				Description:         "Whether HMAC is enabled.",
				MarkdownDescription: "Whether HMAC is enabled.",
			},
			"hmac_string": schema.StringAttribute{
				Optional:            true,
				Description:         "HMAC secret string.",
				MarkdownDescription: "HMAC secret string.",
			},
			"id_extractor_deadline": schema.Int64Attribute{
				Optional:            true,
				Description:         "ID extractor deadline.",
				MarkdownDescription: "ID extractor deadline.",
			},
			"is_inactive": schema.BoolAttribute{
				Optional:            true,
				Description:         "Whether the key is inactive.",
				MarkdownDescription: "Whether the key is inactive.",
			},
			"jwt_data": schema.ObjectAttribute{
				AttributeTypes: map[string]attr.Type{
					"secret": types.StringType,
				},
				Optional:            true,
				Description:         "JWT data for the key.",
				MarkdownDescription: "JWT data for the key.",
			},
			"last_check": schema.Int64Attribute{
				Optional:            true,
				Description:         "The last time the API key was checked, in Unix timestamp format.",
				MarkdownDescription: "The last time the API key was checked, in Unix timestamp format.",
			},
			"last_updated": schema.StringAttribute{
				Optional:            true,
				Description:         "Last updated timestamp.",
				MarkdownDescription: "Last updated timestamp.",
			},
			"max_query_depth": schema.Int64Attribute{
				Optional:            true,
				Description:         "The maximum depth of queries allowed for the API key.",
				MarkdownDescription: "The maximum depth of queries allowed for the API key.",
			},
			"meta_data": schema.MapAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "Custom metadata for the key.",
				MarkdownDescription: "Custom metadata for the key.",
			},
			"monitor": schema.ObjectAttribute{
				AttributeTypes: map[string]attr.Type{
					"trigger_limits": types.ListType{
						ElemType: types.Float64Type,
					},
				},
				Optional:            true,
				Description:         "Monitoring configuration for the key.",
				MarkdownDescription: "Monitoring configuration for the key.",
			},
			"oauth_client_id": schema.StringAttribute{
				Optional:            true,
				Description:         "OAuth client ID.",
				MarkdownDescription: "OAuth client ID.",
			},
			"oauth_keys": schema.MapAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "OAuth keys.",
				MarkdownDescription: "OAuth keys.",
			},
			"org_id": schema.StringAttribute{
				Optional:            true,
				Description:         "Organization ID.",
				MarkdownDescription: "Organization ID.",
			},
			"per": schema.Float64Attribute{
				Optional:            true,
				Description:         "The time period for the rate limit, in seconds.",
				MarkdownDescription: "The time period for the rate limit, in seconds.",
			},
			"quota_max": schema.Int64Attribute{
				Optional:            true,
				Description:         "The maximum quota for the API key, in requests.",
				MarkdownDescription: "The maximum quota for the API key, in requests.",
			},
			"quota_remaining": schema.Int64Attribute{
				Optional:            true,
				Description:         "The remaining quota for the API key, in requests.",
				MarkdownDescription: "The remaining quota for the API key, in requests.",
			},
			"quota_renewal_rate": schema.Int64Attribute{
				Optional:            true,
				Description:         "The rate at which the quota renews, in requests per second.",
				MarkdownDescription: "The rate at which the quota renews, in requests per second.",
			},
			"quota_renews": schema.Int64Attribute{
				Optional:            true,
				Description:         "The time when the quota renews, in Unix timestamp format.",
				MarkdownDescription: "The time when the quota renews, in Unix timestamp format.",
			},
			"rate": schema.Float64Attribute{
				Optional:            true,
				Description:         "The rate limit for the API key, in requests per second.",
				MarkdownDescription: "The rate limit for the API key, in requests per second.",
			},
			"rsa_certificate_id": schema.StringAttribute{
				Optional:            true,
				Description:         "RSA certificate ID.",
				MarkdownDescription: "RSA certificate ID.",
			},
			"session_lifetime": schema.Int64Attribute{
				Optional:            true,
				Description:         "Session lifetime.",
				MarkdownDescription: "Session lifetime.",
			},
			"smoothing": schema.ObjectAttribute{
				AttributeTypes: map[string]attr.Type{
					"enabled":   types.BoolType,
					"threshold": types.Int64Type,
					"trigger":   types.Float64Type,
					"step":      types.Int64Type,
					"delay":     types.Int64Type,
				},
				Optional:            true,
				Description:         "Smoothing configuration for the key.",
				MarkdownDescription: "Smoothing configuration for the key.",
			},
			"tags": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "Tags for the key.",
				MarkdownDescription: "Tags for the key.",
			},
			"throttle_interval": schema.Float64Attribute{
				Optional:            true,
				Description:         "The interval for throttling requests, in seconds.",
				MarkdownDescription: "The interval for throttling requests, in seconds.",
			},
			"throttle_retry_limit": schema.Int64Attribute{
				Optional:            true,
				Description:         "The number of retries allowed for throttled requests.",
				MarkdownDescription: "The number of retries allowed for throttled requests.",
			},
		},
	}
}

type TykgatewayKeyModel struct {
	AccessRights                  types.Map     `tfsdk:"access_rights"`
	Alias                         types.String  `tfsdk:"alias"`
	Allowance                     types.Float64 `tfsdk:"allowance"`
	ApplyPolicies                 types.List    `tfsdk:"apply_policies"`
	BasicAuthData                 types.Object  `tfsdk:"basic_auth_data"`
	Certificate                   types.String  `tfsdk:"certificate"`
	DataExpires                   types.Int64   `tfsdk:"data_expires"`
	DateCreated                   types.String  `tfsdk:"date_created"`
	EnableDetailedRecording       types.Bool    `tfsdk:"enable_detailed_recording"`
	EnableHttpSignatureValidation types.Bool    `tfsdk:"enable_http_signature_validation"`
	Expires                       types.Int64   `tfsdk:"expires"`
	HmacEnabled                   types.Bool    `tfsdk:"hmac_enabled"`
	HmacString                    types.String  `tfsdk:"hmac_string"`
	IdExtractorDeadline           types.Int64   `tfsdk:"id_extractor_deadline"`
	IsInactive                    types.Bool    `tfsdk:"is_inactive"`
	JwtData                       types.Object  `tfsdk:"jwt_data"`
	LastCheck                     types.Int64   `tfsdk:"last_check"`
	LastUpdated                   types.String  `tfsdk:"last_updated"`
	MaxQueryDepth                 types.Int64   `tfsdk:"max_query_depth"`
	MetaData                      types.Map     `tfsdk:"meta_data"`
	Monitor                       types.Object  `tfsdk:"monitor"`
	OauthClientId                 types.String  `tfsdk:"oauth_client_id"`
	OauthKeys                     types.Map     `tfsdk:"oauth_keys"`
	OrgId                         types.String  `tfsdk:"org_id"`
	Per                           types.Float64 `tfsdk:"per"`
	QuotaMax                      types.Int64   `tfsdk:"quota_max"`
	QuotaRemaining                types.Int64   `tfsdk:"quota_remaining"`
	QuotaRenewalRate              types.Int64   `tfsdk:"quota_renewal_rate"`
	QuotaRenews                   types.Int64   `tfsdk:"quota_renews"`
	Rate                          types.Float64 `tfsdk:"rate"`
	RsaCertificateId              types.String  `tfsdk:"rsa_certificate_id"`
	SessionLifetime               types.Int64   `tfsdk:"session_lifetime"`
	Smoothing                     types.Object  `tfsdk:"smoothing"`
	Tags                          types.List    `tfsdk:"tags"`
	ThrottleInterval              types.Float64 `tfsdk:"throttle_interval"`
	ThrottleRetryLimit            types.Int64   `tfsdk:"throttle_retry_limit"`
}

var _ basetypes.ObjectTypable = AccessRightsType{}

type AccessRightsType struct {
	basetypes.ObjectType
}

func (t AccessRightsType) Equal(o attr.Type) bool {
	other, ok := o.(AccessRightsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AccessRightsType) String() string {
	return "AccessRightsType"
}

func (t AccessRightsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowUrlsAttribute, ok := attributes["allow_urls"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_urls is missing from object`)

		return nil, diags
	}

	allowUrlsVal, ok := allowUrlsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_urls expected to be basetypes.ListValue, was: %T`, allowUrlsAttribute))
	}

	apiIdAttribute, ok := attributes["api_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_id is missing from object`)

		return nil, diags
	}

	apiIdVal, ok := apiIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_id expected to be basetypes.StringValue, was: %T`, apiIdAttribute))
	}

	apiNameAttribute, ok := attributes["api_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_name is missing from object`)

		return nil, diags
	}

	apiNameVal, ok := apiNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_name expected to be basetypes.StringValue, was: %T`, apiNameAttribute))
	}

	limitAttribute, ok := attributes["limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limit is missing from object`)

		return nil, diags
	}

	limitVal, ok := limitAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limit expected to be basetypes.ObjectValue, was: %T`, limitAttribute))
	}

	versionsAttribute, ok := attributes["versions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`versions is missing from object`)

		return nil, diags
	}

	versionsVal, ok := versionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`versions expected to be basetypes.ListValue, was: %T`, versionsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AccessRightsValue{
		AllowUrls: allowUrlsVal,
		ApiId:     apiIdVal,
		ApiName:   apiNameVal,
		Limit:     limitVal,
		Versions:  versionsVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewAccessRightsValueNull() AccessRightsValue {
	return AccessRightsValue{
		state: attr.ValueStateNull,
	}
}

func NewAccessRightsValueUnknown() AccessRightsValue {
	return AccessRightsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAccessRightsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AccessRightsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AccessRightsValue Attribute Value",
				"While creating a AccessRightsValue value, a missing attribute value was detected. "+
					"A AccessRightsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AccessRightsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AccessRightsValue Attribute Type",
				"While creating a AccessRightsValue value, an invalid attribute value was detected. "+
					"A AccessRightsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AccessRightsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AccessRightsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AccessRightsValue Attribute Value",
				"While creating a AccessRightsValue value, an extra attribute value was detected. "+
					"A AccessRightsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AccessRightsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAccessRightsValueUnknown(), diags
	}

	allowUrlsAttribute, ok := attributes["allow_urls"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_urls is missing from object`)

		return NewAccessRightsValueUnknown(), diags
	}

	allowUrlsVal, ok := allowUrlsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_urls expected to be basetypes.ListValue, was: %T`, allowUrlsAttribute))
	}

	apiIdAttribute, ok := attributes["api_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_id is missing from object`)

		return NewAccessRightsValueUnknown(), diags
	}

	apiIdVal, ok := apiIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_id expected to be basetypes.StringValue, was: %T`, apiIdAttribute))
	}

	apiNameAttribute, ok := attributes["api_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_name is missing from object`)

		return NewAccessRightsValueUnknown(), diags
	}

	apiNameVal, ok := apiNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_name expected to be basetypes.StringValue, was: %T`, apiNameAttribute))
	}

	limitAttribute, ok := attributes["limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limit is missing from object`)

		return NewAccessRightsValueUnknown(), diags
	}

	limitVal, ok := limitAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limit expected to be basetypes.ObjectValue, was: %T`, limitAttribute))
	}

	versionsAttribute, ok := attributes["versions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`versions is missing from object`)

		return NewAccessRightsValueUnknown(), diags
	}

	versionsVal, ok := versionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`versions expected to be basetypes.ListValue, was: %T`, versionsAttribute))
	}

	if diags.HasError() {
		return NewAccessRightsValueUnknown(), diags
	}

	return AccessRightsValue{
		AllowUrls: allowUrlsVal,
		ApiId:     apiIdVal,
		ApiName:   apiNameVal,
		Limit:     limitVal,
		Versions:  versionsVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewAccessRightsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AccessRightsValue {
	object, diags := NewAccessRightsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAccessRightsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AccessRightsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAccessRightsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAccessRightsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAccessRightsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAccessRightsValueMust(AccessRightsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AccessRightsType) ValueType(ctx context.Context) attr.Value {
	return AccessRightsValue{}
}

var _ basetypes.ObjectValuable = AccessRightsValue{}

type AccessRightsValue struct {
	AllowUrls basetypes.ListValue   `tfsdk:"allow_urls"`
	ApiId     basetypes.StringValue `tfsdk:"api_id"`
	ApiName   basetypes.StringValue `tfsdk:"api_name"`
	Limit     basetypes.ObjectValue `tfsdk:"limit"`
	Versions  basetypes.ListValue   `tfsdk:"versions"`
	state     attr.ValueState
}

func (v AccessRightsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["allow_urls"] = basetypes.ListType{
		ElemType: AllowUrlsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["api_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["api_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["limit"] = basetypes.ObjectType{
		AttrTypes: map[string]attr.Type{
			"rate":                 types.Float64Type,
			"per":                  types.Float64Type,
			"throttle_interval":    types.Float64Type,
			"throttle_retry_limit": types.Int64Type,
			"max_query_depth":      types.Int64Type,
			"quota_max":            types.Int64Type,
			"quota_renews":         types.Int64Type,
			"quota_remaining":      types.Int64Type,
			"quota_renewal_rate":   types.Int64Type,
		},
	}.TerraformType(ctx)
	attrTypes["versions"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.AllowUrls.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_urls"] = val

		val, err = v.ApiId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["api_id"] = val

		val, err = v.ApiName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["api_name"] = val

		val, err = v.Limit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["limit"] = val

		val, err = v.Versions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["versions"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AccessRightsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AccessRightsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AccessRightsValue) String() string {
	return "AccessRightsValue"
}

func (v AccessRightsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	allowUrls := types.ListValueMust(
		AllowUrlsType{
			basetypes.ObjectType{
				AttrTypes: AllowUrlsValue{}.AttributeTypes(ctx),
			},
		},
		v.AllowUrls.Elements(),
	)

	if v.AllowUrls.IsNull() {
		allowUrls = types.ListNull(
			AllowUrlsType{
				basetypes.ObjectType{
					AttrTypes: AllowUrlsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AllowUrls.IsUnknown() {
		allowUrls = types.ListUnknown(
			AllowUrlsType{
				basetypes.ObjectType{
					AttrTypes: AllowUrlsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var versionsVal basetypes.ListValue
	switch {
	case v.Versions.IsUnknown():
		versionsVal = types.ListUnknown(types.StringType)
	case v.Versions.IsNull():
		versionsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		versionsVal, d = types.ListValue(types.StringType, v.Versions.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_urls": basetypes.ListType{
				ElemType: AllowUrlsValue{}.Type(ctx),
			},
			"api_id":   basetypes.StringType{},
			"api_name": basetypes.StringType{},
			"limit": basetypes.ObjectType{
				AttrTypes: map[string]attr.Type{
					"rate":                 types.Float64Type,
					"per":                  types.Float64Type,
					"throttle_interval":    types.Float64Type,
					"throttle_retry_limit": types.Int64Type,
					"max_query_depth":      types.Int64Type,
					"quota_max":            types.Int64Type,
					"quota_renews":         types.Int64Type,
					"quota_remaining":      types.Int64Type,
					"quota_renewal_rate":   types.Int64Type,
				},
			},
			"versions": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	limitVal, d := types.ObjectValue(v.Limit.AttributeTypes(ctx), v.Limit.Attributes())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_urls": basetypes.ObjectType{
				AttrTypes: v.Limit.AttributeTypes(ctx),
			},
			"api_id": basetypes.ObjectType{
				AttrTypes: v.Limit.AttributeTypes(ctx),
			},
			"api_name": basetypes.ObjectType{
				AttrTypes: v.Limit.AttributeTypes(ctx),
			},
			"limit": basetypes.ObjectType{
				AttrTypes: v.Limit.AttributeTypes(ctx),
			},
			"versions": basetypes.ObjectType{
				AttrTypes: v.Limit.AttributeTypes(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"allow_urls": basetypes.ListType{
			ElemType: AllowUrlsValue{}.Type(ctx),
		},
		"api_id":   basetypes.StringType{},
		"api_name": basetypes.StringType{},
		"limit": basetypes.ObjectType{
			AttrTypes: v.Limit.AttributeTypes(ctx),
		},
		"versions": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allow_urls": allowUrls,
			"api_id":     v.ApiId,
			"api_name":   v.ApiName,
			"limit":      limitVal,
			"versions":   versionsVal,
		})

	return objVal, diags
}

func (v AccessRightsValue) Equal(o attr.Value) bool {
	other, ok := o.(AccessRightsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowUrls.Equal(other.AllowUrls) {
		return false
	}

	if !v.ApiId.Equal(other.ApiId) {
		return false
	}

	if !v.ApiName.Equal(other.ApiName) {
		return false
	}

	if !v.Limit.Equal(other.Limit) {
		return false
	}

	if !v.Versions.Equal(other.Versions) {
		return false
	}

	return true
}

func (v AccessRightsValue) Type(ctx context.Context) attr.Type {
	return AccessRightsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AccessRightsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow_urls": basetypes.ListType{
			ElemType: AllowUrlsValue{}.Type(ctx),
		},
		"api_id":   basetypes.StringType{},
		"api_name": basetypes.StringType{},
		"limit": basetypes.ObjectType{
			AttrTypes: map[string]attr.Type{
				"rate":                 types.Float64Type,
				"per":                  types.Float64Type,
				"throttle_interval":    types.Float64Type,
				"throttle_retry_limit": types.Int64Type,
				"max_query_depth":      types.Int64Type,
				"quota_max":            types.Int64Type,
				"quota_renews":         types.Int64Type,
				"quota_remaining":      types.Int64Type,
				"quota_renewal_rate":   types.Int64Type,
			},
		},
		"versions": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = AllowUrlsType{}

type AllowUrlsType struct {
	basetypes.ObjectType
}

func (t AllowUrlsType) Equal(o attr.Type) bool {
	other, ok := o.(AllowUrlsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AllowUrlsType) String() string {
	return "AllowUrlsType"
}

func (t AllowUrlsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	methodsAttribute, ok := attributes["methods"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`methods is missing from object`)

		return nil, diags
	}

	methodsVal, ok := methodsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`methods expected to be basetypes.ListValue, was: %T`, methodsAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AllowUrlsValue{
		Methods: methodsVal,
		Url:     urlVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewAllowUrlsValueNull() AllowUrlsValue {
	return AllowUrlsValue{
		state: attr.ValueStateNull,
	}
}

func NewAllowUrlsValueUnknown() AllowUrlsValue {
	return AllowUrlsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAllowUrlsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AllowUrlsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AllowUrlsValue Attribute Value",
				"While creating a AllowUrlsValue value, a missing attribute value was detected. "+
					"A AllowUrlsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AllowUrlsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AllowUrlsValue Attribute Type",
				"While creating a AllowUrlsValue value, an invalid attribute value was detected. "+
					"A AllowUrlsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AllowUrlsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AllowUrlsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AllowUrlsValue Attribute Value",
				"While creating a AllowUrlsValue value, an extra attribute value was detected. "+
					"A AllowUrlsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AllowUrlsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAllowUrlsValueUnknown(), diags
	}

	methodsAttribute, ok := attributes["methods"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`methods is missing from object`)

		return NewAllowUrlsValueUnknown(), diags
	}

	methodsVal, ok := methodsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`methods expected to be basetypes.ListValue, was: %T`, methodsAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewAllowUrlsValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewAllowUrlsValueUnknown(), diags
	}

	return AllowUrlsValue{
		Methods: methodsVal,
		Url:     urlVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewAllowUrlsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AllowUrlsValue {
	object, diags := NewAllowUrlsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAllowUrlsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AllowUrlsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAllowUrlsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAllowUrlsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAllowUrlsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAllowUrlsValueMust(AllowUrlsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AllowUrlsType) ValueType(ctx context.Context) attr.Value {
	return AllowUrlsValue{}
}

var _ basetypes.ObjectValuable = AllowUrlsValue{}

type AllowUrlsValue struct {
	Methods basetypes.ListValue   `tfsdk:"methods"`
	Url     basetypes.StringValue `tfsdk:"url"`
	state   attr.ValueState
}

func (v AllowUrlsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["methods"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Methods.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["methods"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AllowUrlsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AllowUrlsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AllowUrlsValue) String() string {
	return "AllowUrlsValue"
}

func (v AllowUrlsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var methodsVal basetypes.ListValue
	switch {
	case v.Methods.IsUnknown():
		methodsVal = types.ListUnknown(types.StringType)
	case v.Methods.IsNull():
		methodsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		methodsVal, d = types.ListValue(types.StringType, v.Methods.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"methods": basetypes.ListType{
				ElemType: types.StringType,
			},
			"url": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"methods": basetypes.ListType{
			ElemType: types.StringType,
		},
		"url": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"methods": methodsVal,
			"url":     v.Url,
		})

	return objVal, diags
}

func (v AllowUrlsValue) Equal(o attr.Value) bool {
	other, ok := o.(AllowUrlsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Methods.Equal(other.Methods) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v AllowUrlsValue) Type(ctx context.Context) attr.Type {
	return AllowUrlsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AllowUrlsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"methods": basetypes.ListType{
			ElemType: types.StringType,
		},
		"url": basetypes.StringType{},
	}
}
